{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Community Documents Site","text":"<p>The Qitmeer community offers documentation and tutorials on Qitmeer, which is maintained and developed by blockchain and open-source enthusiasts.</p> <p>Qitmeer is a blockDAG-based public blockchain infrastructure built on PoW. It features a UTXO-based account system and also supports a compatible EVM for the deployment of smart contracts. Qitmeer has a roadmap to support L2 ZK-rollups and other consensus algorithms in the future.</p>"},{"location":"#name-conventions","title":"Name Conventions","text":"<p>Name conventions used in the Qitmeer blockchain system and networks are as follows:</p> <ul> <li> <p>Qitmeer: the name of the BlockDAG architecture with POW consensus based qitmeer blockchain infrastructure. It provides a stable, secure, and fair decentralized infrastructure for upper layer applications.</p> </li> <li> <p>QNG: an EVM (Ethereum Virtual Machine) compatible blockchain layer that runs seamlessly with \u201cQitmeer\u201d infrastructure. It provides an easy interface to deploy any EVM compatible dAPPs.</p> </li> <li> <p>Amana: layer 2 solution for QNG, designed to provide high performance and scalability. Currently, Amana is only available on testnet and is based on a Proof of Authority (PoA) consensus algorithm.</p> </li> </ul>"},{"location":"#supporting-websites","title":"Supporting Websites:","text":"<ul> <li>GitHub Repo</li> <li>Qitmeer - Mainnet</li> <li>QNG - Mainnet</li> <li>Qitmeer - Testnet</li> <li>QNG - Testnet</li> </ul>"},{"location":"#key-community-documents","title":"Key Community Documents","text":"<ul> <li>What is BlockDAG</li> <li>Install and run Qitmeer Testnode</li> <li>QNG and Deploying Smart Contracts</li> <li>Solidity Tutorial (Part 1)</li> <li>Solidity Tutorial (Part 2)</li> <li>Solidity Tutorial (Part 3)</li> </ul> <p>For latest Qitmeer project source code visit Qitmeer/QNG.</p>"},{"location":"Installation_Running_qng_node/","title":"Installation and Running Testing Qitmeer Node","text":""},{"location":"Installation_Running_qng_node/#prerequisites","title":"Prerequisites","text":"<ul> <li>Golang (Go) - Download and installation can be found at: https://go.dev/doc/install</li> </ul>"},{"location":"Installation_Running_qng_node/#compile-and-build-meer-node","title":"Compile and build MEER node","text":"<ul> <li>Clone the repository: <code>git clone https://github.com/Qitmeer/qng.git</code></li> <li>Enter the <code>qng</code> directory: <code>cd qng</code></li> <li>Run <code>make</code> command</li> </ul> <pre><code>&gt; git clone https://github.com/Qitmeer/qng.git\n&gt; cd qng\n&gt; make\n</code></pre> <p>Running <code>make all</code> will also install qx, relay and fastIBD</p>"},{"location":"Installation_Running_qng_node/#install-qx","title":"Install qx","text":"<p>qx is a command-line tool and can be regarded as the \u201cSwiss Army Knife of Qitmeer\u201d. It can provide a range of functionalities such as: random seed generation, public/private key generation, constructing transactions etc.</p>"},{"location":"Installation_Running_qng_node/#installation-instructions","title":"Installation Instructions:","text":"<p>This process can be skipped if you ran the <code>make all</code> command in the previous section.</p> <ul> <li>Enter the <code>qng/cmd/qx</code> directory: <code>cd qng/cmd/qx</code></li> <li>Run <code>go build</code> (you may have to run <code>go mod tidy</code> if you run into issues regarding dependencies)</li> <li>To run the tool, simply type <code>./qx</code></li> </ul> <pre><code>&gt; cd qng/cmd/qx\n&gt; go build\n&gt; ./qx\n</code></pre> <p>Installation of qx is not mandatory but may prove to be useful to complete certain tasks</p>"},{"location":"Installation_Running_qng_node/#create-wallet-kahf-wallet","title":"Create Wallet (KAHF Wallet)","text":"<p> - Download and install the app KAHF wallet available at: https://www.kahf.io/. KAHF is a multi-chain wallet that provides a user-friendly GUI to manage all your digital assets. After following the instructions on-screen, ensure that Qitmeer Testnet is also selected in order to manage assets in the Qitmeer test network environment.</p>"},{"location":"Installation_Running_qng_node/#export-private-key","title":"Export Private Key","text":"<p>Using the app, you will also be able to export your private key:</p> <p>1) Click on the icon on the top-right hand corner:</p> <p></p> <p>2) Select Check Private Key and enter in your password 3) Select Qitmeer Testnet Assets (UTXO) 4) Your private key should now be displayed. You also have the option to press Copy to copy to your clipboard</p>"},{"location":"Installation_Running_qng_node/#create-wallet-using-qx","title":"Create Wallet (Using qx)","text":"<p>You can use the qx command line to generate your own wallet:</p> <ul> <li>Enter the directory where you have placed the qx binary file (if you followed the previous instructions above, this should be at <code>qng/cmd/qx</code></li> <li>Generate a cryptographic secure pseudo-random entropy (seed) using the command <code>./qx entropy</code></li> </ul> <pre><code>&gt; ./qx entropy\nOutput: 91b69389c7df9aad1bbb58b0667f322165b965f16184aa613ee4792e27b9be28\n</code></pre> <p>To produce a mnemonic word-list (BIP39) enter the command:</p> <p><pre><code>&gt; ./qx mnemonic-new 91b69389c7df9aad1bbb58b0667f322165b965f16184aa613ee4792e27b9be28\nOutput: museum region tiny moral whale final humble help race crop smart drift fortune real sheriff correct price antique ribbon venture tiny system weather all\n</code></pre> With this mnemonic, you can export your wallet to KAHF wallet or any other compatible wallet.</p> <p>Use the following commands to generate the Private Key, Public Key, Address, Public Key (PK) Address and ETH Address:</p> <p>WARNING: The entropy and other values generated here, exist purely for demonstration purposes. These values should only be used in a test environment and not used to hold assets with real monetary value.</p> <p>Private Key: <pre><code>&gt; ./qx mnemonic-new &lt;entropy&gt; | ./qx mnemonic-to-seed | ./qx ec-new\n&gt; ./qx mnemonic-new 91b69389c7df9aad1bbb58b0667f322165b965f16184aa613ee4792e27b9be28 | ./qx mnemonic-to-seed | ./qx ec-new\nOutput: 12d76cda3b0d4dde6c8cad7f0df2ceb5b1690b4f3725f94226095cf04d3f21e2\n</code></pre> Public Key: <pre><code>&gt; ./qx mnemonic-new &lt;entropy&gt; | ./qx mnemonic-to-seed | ./qx ec-new | ./qx ec-to-public\n&gt; ./qx mnemonic-new 91b69389c7df9aad1bbb58b0667f322165b965f16184aa613ee4792e27b9be28 | ./qx mnemonic-to-seed | ./qx ec-new | ./qx ec-to-public\nOutput: 0363e43e0dfda44a34e1653f4feeb487fa8ccb88ba5b975a888913190e4a94abcd\n</code></pre> Address: <pre><code>&gt; ./qx mnemonic-new &lt;entropy&gt; | ./qx mnemonic-to-seed | ./qx ec-new | ./qx ec-to-public | ./qx ec-to-addr -v &lt;network&gt;\n&gt; ./qx mnemonic-new 91b69389c7df9aad1bbb58b0667f322165b965f16184aa613ee4792e27b9be28 | ./qx mnemonic-to-seed | ./qx ec-new | ./qx ec-to-public | ./qx ec-to-addr -v testnet\nOutput: TnP7hbozSYpv8vPzHFnVfwVSJR9hhgoW5P7\n</code></pre> Public Key Address: <pre><code>&gt; ./qx mnemonic-new &lt;entropy&gt; | ./qx mnemonic-to-seed | ./qx ec-new | ./qx ec-to-public | ./qx ec-to-pkaddr -v testnet\n&gt; ./qx mnemonic-new 91b69389c7df9aad1bbb58b0667f322165b965f16184aa613ee4792e27b9be28 | ./qx mnemonic-to-seed | ./qx ec-new | ./qx ec-to-public | ./qx ec-to-pkaddr -v testnet\nOutput: Tk6ts4JPqiyS5Xn1Jh9XmjADDtnBMDpoDCbcMKV2FkeGqjDJb1azt\n</code></pre></p> <p>The <code>-v</code> flag represents the type of network. By default this is set to \"mainnet\". </p> <p>ETH Address (for use in MeerEVM): <pre><code>&gt; ./qx mnemonic-new &lt;entropy&gt; | ./qx mnemonic-to-seed | ./qx ec-new | ./qx ec-to-public | ./qx ec-to-ethaddr\n&gt; ./qx mnemonic-new 91b69389c7df9aad1bbb58b0667f322165b965f16184aa613ee4792e27b9be28 | ./qx mnemonic-to-seed | ./qx ec-new | ./qx ec-to-public | ./qx ec-to-ethaddr\nOutput: 0x86209f32b6490Ca551b09fb4c8f70B79f513cF73\n</code></pre></p>"},{"location":"Installation_Running_qng_node/#commands-list","title":"Commands List:","text":"<ul> <li><code>mnemonic-new</code>:  create a mnemonic word-list (BIP39) from an entropy</li> <li><code>mnemonic-to-seed</code>: convert a mnemonic word-list (BIP39) to its 512 bits seed</li> <li><code>ec-new</code>: create a new Elliptic Curve (EC) private key from an entropy (seed)</li> <li><code>ec-to-public</code>: derive the EC public key from a EC private key</li> <li><code>ec-to-addr</code>:  convert an EC public key to a payment address</li> <li><code>ec-to-pkaddr</code>: convert an EC public key to a payment public key address</li> <li><code>ec-to-ethaddr</code>: convert an EC public key to a Ethereum address</li> </ul>"},{"location":"Installation_Running_qng_node/#mining-test-coins","title":"Mining Test Coins","text":"<p>There are several ways in which to mine MEER test coins for use in the Qitmeer testnet. Regardless of which method is used, the MEER node must have the <code>--miner</code> flag enabled as well as <code>--miningaddr=&lt;block-reward-address&gt;</code>. </p> <p>If the block reward were to be sent to address \"TnSh92n7s4XbRiPmNrtYDttMugLVycsuars\", then the flag would be <code>--miningaddr=TnSh92n7s4XbRiPmNrtYDttMugLVycsuars</code>. Both the address and PK address can be used when setting this flag.</p> <p>These include:  - Inserting the <code>--generate</code> flag before running the MEER node. <code>./qng \u2013-testnet \u2013-miner \u2013-miningaddr=&lt;block-reward-address&gt; \u2013-generate</code>. This method is the easiest to implement and will attempt to mine blocks using the onboard CPU.  - Installing and running the qitmeer-miner. This method provides a greater level of control of the mining process allowing users to utilise their GPU for mining instead of their CPU, participate as a solo miner or as part of a pool etc</p> <p>Once you have successfully received miner reward and obtained some test coins, you can view the balance of your account on the Qitmeer BlockDAG Explorer Testnet or KAHF Wallet. </p>"},{"location":"What_is_BlockDAG/","title":"What is BlockDAG?","text":"<p>The Qitmeer network utilises a blockDAG structure as opposed to the traditional blockchain structure found in most popular Distributed Ledger Technology (DLT). Although the terms blockchain and blockDAG are often used interchangeably, they are entirely different data structures (they may retain some similar features as in Qitmeer\u2019s case which will be discussed later on). </p>"},{"location":"What_is_BlockDAG/#dag-directed-acyclic-graph","title":"DAG - Directed Acyclic Graph","text":"<p>Before we delve into what blockDAG is, we need to address, what the \u201cDAG\u201d part stands for. DAG is an acronym for:</p> <p>D - Directed</p> <p>A - Acyclic</p> <p>G - Graph</p> <p>DAG is simply a directed graph containing nodes and edges which have no cycles. DAGs themselves are not a brand new concept and have already seen widespread applications in biology, computer science and even the widely popular version control system - Git. </p> <p></p> <p>Fig 1. An example of a DAG</p>"},{"location":"What_is_BlockDAG/#bitcoin-security-scalability-problem","title":"Bitcoin Security-Scalability Problem","text":"<p>Bitcoin, one of the earliest and most popular forms of cryptocurrency has over the years proved to be very secure with the underlying security of the network remaining intact. However, whilst its greatest strength may lie in its security, this has come at a tradeoff when it comes to its scalability. </p> <p>Most notably:</p> <ul> <li>Bitcoin is slow\u2026very slow with 5-7 TPS (Transactions Per Second)</li> <li>Block size is restricted to \u22481MB (post-Segwit this has a practical limit of about \u22482MB)</li> <li>Block creation time is restricted to 1 block \u2248 10 minutes</li> </ul> <p>Whilst these parameters might seem impractical, it is because of this impracticality that has made Bitcoin soo secure. In theory, by increasing the block size or creation time, the longer it will take for these blocks to propagate through the network. Since nodes may not have access to the most recent block on the network, they will continue mining on what they perceive is the current block. Once the PoW (Proof of Work) for this block has been completed, it would create a fork on the network (since you now have multiple blocks pointing to a single preceding block). </p> <p>As Bitcoin uses the longest chain rule, any blocks outside of this chain (such as those in forks) would become stale and be rejected from the network. Introducing too many stale blocks would eventually degrade the security of the network. </p> <p>Essentially:</p> <p>More/Larger Blocks \u2192 Slower Block Propagation \u2192 More Forks \u2192 Less Security</p>"},{"location":"What_is_BlockDAG/#blockdag","title":"BlockDAG","text":"<p>BlockDAG is a DAG whereby the nodes represent the blocks and the edges represent references to its predecessor blocks. Unlike blockchain, where a single block is created within a certain time period, a blockDAG is able to create multiple blocks concurrently enabling greater TPS. Moreover, in a blockchain, a block can have only one single reference to its predecessor whereas in a DAG, a block can reference multiple predecessor blocks. This has the added effect of being able to determine which blocks were created honestly and which ones were created by a malicious adversary.</p> <p></p> <p>Fig 2. Example of a blockDAG</p> <p>At the end of the day, blockDAG is merely a way of representing blocks and does not address other pressing matters such as how to deal with double-spending or the overall ordering of the blocks. For this, Qitmeer has adopted a hybrid consensus protocol combining both the SPECTRE and the GHOSTDAG protocol to create what it calls the MeerDAG consensus **protocol. This in summary addresses the double spending issue as well as provide linear ordering of the blocks.</p> <p>A more detailed explanation on blockDAG and MeerDAG can be found here and here.</p>"},{"location":"meerEVM_deploying_SmartContracts/","title":"QNG - EVM &amp; Deploying Smart Contracts","text":""},{"location":"meerEVM_deploying_SmartContracts/#qng-setting-up-node","title":"QNG - setting up node","text":"<p>To interact with the QNG (testnet), you would need to configure your Qitmeer node by including both the <code>--testnet</code> and <code>--evmenv</code> flag and specifying the necessary parameters before starting the node.</p> <p>Interacting with QNG requires the client sending a series of JSON-RPC API methods to the node which can only be done by enabling a server on the node to accept JSON-RPC requests. </p> <p>Currently you can use the API via RPC through these protocols: - HTTP - WebSocket</p>"},{"location":"meerEVM_deploying_SmartContracts/#http","title":"HTTP","text":"<p>To enable the HTTP server, you would need to insert the <code>--http</code> parameter inside of <code>--evmenv</code> flag: </p> <pre><code>&gt; ./qng --testnet --evmenv=\"--http\"\n</code></pre> <p>By default, the port number should be set to 18535 but this can be altered by modifying <code>--http.port=&lt;port-number&gt;</code>. For example, if you want to set the port number to 12345, then you would need to input the command: <code>./qng --testnet --evmenv=\"--http --http.port=1234\"</code></p> <p>You can also specify the JSON-RPC API that you would like to use through the <code>--http.api</code> parameter: </p> <pre><code>&gt; ./qng --testnet --evmenv=\"--http --http.api=eth,net,rpc,web3,personal,debug\"\n</code></pre> <p>By default, only <code>eth</code>, <code>net</code>, <code>rpc</code> and <code>web3</code> API methods are provided if <code>--http.api</code> is not explicitly specified</p>"},{"location":"meerEVM_deploying_SmartContracts/#websocket","title":"WebSocket","text":"<p>To enable the WebSockets, you would need to insert the <code>--ws</code> parameter inside of <code>--evmenv</code> flag:</p> <pre><code>&gt; ./qng --testnet --evmenv=\"--ws\"\n</code></pre> <p>Again, similar to HTTP, the port number by default is set to 18536. This can be altered by <code>--ws.port=&lt;port-number&gt;</code>. For example, if you want to set the port number to 12345, then you would need to input the command: <code>./qng --testnet --evmenv=\"--ws --ws.port=12345\"</code></p>"},{"location":"meerEVM_deploying_SmartContracts/#clish","title":"cli.sh","text":"<p>cli.sh is a bash script that will allow you to run JSON-RPC methods on the Qitmeer UTXO network (not QNG).</p> <p>Before the running the script you must set the corresponding variables to match the settings of the Qitmeer UTXO RPC server running on the node:</p> <ul> <li><code>$host</code> - IP address of host (default: 127.0.0.1)</li> <li><code>$port</code> - port number (default: 1234)</li> <li><code>$user</code> - username for RPC server (default: \"test\") </li> <li><code>$pass</code> - password for RPC server (default: \"test\")</li> </ul> <p>The port number for the Qitmeer RPC server is by default, set to 18131 unless changed otherwise. </p> <p>Again, the configuration settings must match the RPC server for the Qitmeer network and not QNG or what has been entered in the <code>--evmenv</code> flag.</p> <p>If the default values do not correspond to those set on the node, then, they must be changed. You can alter the settings by issuing the following command:</p> <pre><code>export host=&lt;host-IP&gt; port=&lt;port-number&gt; user=&lt;username&gt; pass=&lt;password&gt;\n</code></pre> <p>It may be easier for you to simply change the default values on the script if your not going to change the values often. That way you don't have to worry about your environment variables being accurately set.</p> <p>This could be done by modifying this portion of the script : </p> <pre><code>// cli.sh - line 641\nfunction get_result(){\nlocal proto=\"https\"\nif [ $notls -eq 1 ]; then\nproto=\"http\"\nfi\nif [ -z \"$host\" ]; then\nhost=127.0.0.1\n  fi\nif [ -z \"$port\" ]; then\nport=1234\nfi\nif [ -z \"$user\" ]; then\nuser=\"test\"\nfi\nif [ -z \"$pass\" ]; then\npass=\"test\"\nfi\n</code></pre>"},{"location":"meerEVM_deploying_SmartContracts/#cross-chain-exchange-qitmeer-qng","title":"Cross-chain Exchange (Qitmeer -&gt; QNG)","text":"<p>It is possible to exchange your MEER coins from the Qitmeer UTXO network to QNG.</p>"},{"location":"meerEVM_deploying_SmartContracts/#method-1-using-kahf-wallet","title":"Method 1: Using KAHF Wallet","text":"<p>You can use the KAHF wallet app to easily transfer MEER from Qitmeer UTXO to QNG</p> <ol> <li>On the home page, click on the last icon labelled \"Transfer\"</li> </ol> <p></p> <ol> <li> <p>Select the address you would like to send it to and enter the amount.</p> </li> <li> <p>Click \"Confirm\" and enter your password or fingerprint (if this has been set up).</p> </li> <li> <p>You should see the transaction details on the screen. Click on \"Transfer\" to finalise the transaction.</p> </li> </ol> <p></p>"},{"location":"meerEVM_deploying_SmartContracts/#add-qng-to-metamask","title":"Add QNG to Metamask","text":"<p>You must have the Metamask browser extension installed before proceeding ahead. </p>"},{"location":"meerEVM_deploying_SmartContracts/#method-1-use-public-rpc-node-easier-option","title":"Method 1: use public RPC node (easier option)","text":"<p>You can take advantage of a public RPC endpoint to deploy your smart contracts, rather than host the infrastructure yourself. </p> <p>The first thing to do is to add the QNG network to your Metamask wallet.</p> <p>Click on the Metamask browser extension icon and click on the circular icon on the top right:</p> <p></p> <p>Next click on Settings &gt; Networks &gt; Add Network</p> <p>Add the following information to allow the wallet to connect to the RPC endpoint: </p> <ul> <li>Network Name: QNG - Testnet </li> <li>New RPC URL: https://explorer.qitmeer.io/rpc</li> <li>Chain ID: 223</li> <li>Currency Symbol: MEER</li> <li>Block Explorer URL: https://qng-testnet.meerscan.io/</li> </ul> <p>It should look something like this:</p> <p></p> <p>Finally, click on the \"Save\" button. Metamask will attempt to connect to the endpoint. If you do not encounter any errors then the process has been a success.</p>"},{"location":"meerEVM_deploying_SmartContracts/#method-2-use-own-rpc-node","title":"Method 2: use own RPC node","text":"<p>If you would prefer to use your own node, you can configure Metamask to connect to your RPC endpoint using the same method mentioned above. </p> <ol> <li>The first step is to have the node running with the <code>--evmenv</code> flag enabled with the necessary parameters: <code>./qng --testnet --evmenv=\"--http --http.port=18545 --http.corsdomain=chrome-extension://nkbihfbeogaeaoehlefnkodbefgpgknn\"</code></li> </ol> <p><code>--http.corsdomain</code> must be enabled, with the value equal to the URL of the client that wants to connect to our node. Although you can set the value to \"\" to allow anybody to connect to the node, this is generally bad practice and should only be done inside of a test environment or if you know what you are doing*!</p> <p>To find the value of <code>--http.corsdomain</code>, click on the Metamask icon and click on account options:</p> <p></p> <p>Click on \"Expand View\" and copy the URL of the address bar. You should see it starting with <code>chrome-extension://</code> or <code>moz-extension://</code> and copy the URL but removing the <code>/home.html</code> part</p> <p></p> <ol> <li> <p>Add the network to the Metamask wallet using the previous method outlined above. Only the \"New RPC URL\" value should be changed with the remaining parameters being the same as above.</p> </li> <li> <p>Click on the \"Save\" button. Metamask will attempt to connect to the endpoint. If you do not encounter any errors then the process has been a success. </p> </li> </ol>"},{"location":"meerEVM_deploying_SmartContracts/#deploy-smart-contract-on-qng","title":"Deploy Smart Contract on QNG","text":"<p>In this section we will attempt to deploy a \"Hello World\" smart contract on QNG. In this example we will be using Remix IDE although you can use any library or development environment (such as Hardhat, Truffle etc.) to complete this task.</p> <p>The contract we will attempt to deploy is: <pre><code>// Available at https://blog.chain.link/how-to-create-a-hello-world-smart-contract-with-solidity/\n// SPDX-License-Identifier: MIT\npragma solidity &gt;=0.7.0 &lt;0.9.0;\ncontract HelloWorld {\nfunction sayHelloWorld() public pure returns (string memory) {\nreturn \"Hello World\";\n}\n}\n</code></pre></p>"},{"location":"meerEVM_deploying_SmartContracts/#connect-metamask-to-remix-ide","title":"Connect Metamask to Remix IDE","text":"<ol> <li>Select the right network for your Metamask wallet. This should be \"QNG - Testnet\" (or whatever you decided to call it)</li> </ol> <ol> <li>Next visit the Remix IDE website and click on the \"Deploy and run transactions icon\"</li> </ol> <ol> <li>Click on the \"Environment\" tab and select \"Injected Provider - Metamask\". You should recieve a pop-up from Metmask asking whether you would like to connect your wallet. You should click accept. If it was successful, you should not see any errors.</li> </ol> <ol> <li>Click on the \"File Explorer\" tab, click on \"Create new file\" and name it <code>hello-world.sol</code> and copy and paste the following code: <pre><code>// Available at https://blog.chain.link/how-to-create-a-hello-world-smart-contract-with-solidity/\n// SPDX-License-Identifier: MIT\npragma solidity &gt;=0.7.0 &lt;0.9.0;\ncontract HelloWorld {\nfunction sayHelloWorld() public pure returns (string memory) {\nreturn \"Hello World\";\n}\n}\n</code></pre></li> </ol> <ol> <li>Press CTRL + S to compile your contract. You should see a tick if the contract was compiled successfully. </li> </ol> <ol> <li>Click on the \"Deploy and run transactions tab\" and select the \"hello-world.sol\" smart contract. Click \"deploy\" to deploy onto QNG. You should get a prompt by Metamask asking whether you would like to confirm the transaction. Click \"accept\". </li> </ol> <p>We can view our transaction on the QNG Testnet Explorer: https://testnet.qng.meerscan.io/tx/0xbf52631a396aaac1f90c58ee721e5c0c09882564ab2f2e3c52444804780695ca</p> <p></p> <ol> <li>Contracts that have been deployed will appear in the \"Deployed Contracts\" section. Click on the \"sayHelloWorld\" button to call the function. The output should appear below as <code>0:string:Hello World</code></li> </ol> <p></p> <p>As <code>sayHelloWorld()</code> is a pure function, in this instance, a transaction will not be created unlike the contract creation process.</p>"},{"location":"solidity_tutorial_basics_part_1/","title":"Solidity Tutorial - Basics (Part 1)","text":"<p>Solidity is an object-oriented, high-level language for implementing smart contracts. It is influenced by other high level languages such as C++, Python and JavaScript for writing smart contracts specifically for the EVM (Ethereum Virtual Machine). Whilst smart contracts can be written in various different languages, Solidity continues to remain the most popular amongst blockchain developers (as of writing of course).  </p> <p>In these series of tutorials, we will be covering certain key concepts, so that by the end, you will be able to create your very own smart contract \ud83d\ude42</p>"},{"location":"solidity_tutorial_basics_part_1/#spdx-license-identifier","title":"SPDX License Identifier","text":"<p>On the top of some smart contracts, you may find something like this: </p> <pre><code>// SPDX-License-Identifier: MIT\n</code></pre> <p>This line is simply a machine-readable SPDX license identifier that indicates which license you would like your source code to fall under. In the example above, the smart contract will use the MIT  license. Having a license identifier is not mandatory and you will be able to compile your smart contracts just fine without it. It will be important if you do wish to open-source your code so that others can modify and redistribute your code. </p> <p>If you don\u2019t wish to use the MIT license, the full SPDX license list can be found here.</p>"},{"location":"solidity_tutorial_basics_part_1/#pragmas","title":"Pragmas","text":"<p>After including your license, the next thing you may come across is something like this:</p> <pre><code>pragma solidity &gt;=0.8.2 &lt;0.9.0;\n</code></pre> <p>Pragmas are used in Solidity to enable certain compiler features and checks. One of the most common is the version pragma (as shown above) which checks that the version of the Solidity compiler matches the version explicitly stated in the smart contract. You can specify a single, fixed version number or a specific range using comparison operators.</p> <p>Version pragma is important as each <code>0.x.0</code> introduces breaking changes that may make your smart contract incompatible with the previous version. The version pragma is not mandatory but it will certainly help eliminate a lot of compilation errors and bugs if you knew which version the smart contract was compiled under!   </p>"},{"location":"solidity_tutorial_basics_part_1/#imports","title":"Imports","text":"<p>Like with any other code you would write, you may need to import other files/libraries into your current code. With Solidity, you can import both local and external files using the <code>import</code> keyword.</p>"},{"location":"solidity_tutorial_basics_part_1/#local","title":"Local","text":"<p>If you have two files Foo.sol and Import.sol in a file structure like this:</p> <pre><code>\u251c\u2500\u2500 Import.sol\n\u2514\u2500\u2500 Foo.sol\n</code></pre> <p>You can import Foo.sol into Import.sol by specifying its relative path:</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n// import Foo.sol from current directory\nimport \"./Foo.sol\";\n</code></pre>"},{"location":"solidity_tutorial_basics_part_1/#external","title":"External","text":"<p>You can also import from external sources such as from GitHub, NPM and IPFS:</p> <pre><code>// Import from GithHub URL\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.5.0/contracts/math/SafeMath.sol\";\n// Import from NPM\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n// Import from IPFS\nimport 'ipfs://Qmdyq9ZmWcaryd1mgGZ4PttRNctLGUSAMpPqufsk6uRMKh';\n</code></pre>"},{"location":"solidity_tutorial_basics_part_1/#comments","title":"Comments","text":"<p>Solidity allows for single and multi-line comments. Single line comments are denoted with <code>//</code> and multi-line comments are denoted with <code>/*...*/</code></p> <pre><code>// This is a single-line comment.\n/*\nThis is a\nmulti-line comment.\n*/\n</code></pre>"},{"location":"solidity_tutorial_basics_part_2/","title":"Solidity Tutorial - Basics (Part 2)","text":"<p>In this section, we\u2019ll be delving deeper into Solidity and covering further concepts such as: variables (add more here)</p>"},{"location":"solidity_tutorial_basics_part_2/#variables","title":"Variables","text":"<p>Solidity is a statically typed language meaning that the type of the variable must be explicitly declared before a value can be assigned to it. For instance, if you wanted to store a 256-bit integer into variable <code>a</code>, you would write:</p> <pre><code>// Declare an integer\nint a;\na = 20;\n// or like this\nint a = 20;\n// or since int and int256 are aliases, you could write:\nint256 a = 20;\n</code></pre> <p>In Solidity variables can be categorised into one of two types:</p> <ul> <li>Value Types</li> <li>Reference Types</li> </ul>"},{"location":"solidity_tutorial_basics_part_2/#value-types","title":"Value Types","text":"<p>Value types basic data types whose variables are passed by value when used in function arguments or assignments. This means that when they are assigned or passed as arguments, a copy of the value is created</p> <p>These types include:</p> <ul> <li>Boolean</li> <li>Signed/Unsigned Integer</li> <li>Fixed Point Numbers (although not fully supported by Solidity yet)</li> <li>Address (Ethereum)</li> <li>Fixed-size Bytes</li> <li>Enum</li> </ul> <pre><code>// Integer\nint myInt = -20;\n// Unsigned Integer\nuint myUint = 30;\n//Boolean\nbool myBool = true;\n// Etheruem Address\naddress myAddress = 0x751bc4cd7E77033fBDb9206fF306549d6dD017f8;\n// Bytes (can be between bytes1..32)\nbytes32 myBytes = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n// Enums (return uint depending on index)\nenum Button {\nOFF,\nPENDING,\nON\n}\n/*\nReturns uint8 depending on the index of which element was selected\nOFF - 0\nON - 1\n*/\n// This would return a uint with value 0\nButton myButton = Button.OFF;\n// This would return a uint with value 1\nButton myButton = Button.PENDING\n\n// This would return a uint with value 2\nButton myButton = Button.ON\n</code></pre>"},{"location":"solidity_tutorial_basics_part_2/#reference-types","title":"Reference Types","text":"<p>Reference types are types that store a reference to the memory location where the data is stored, rather than the data itself. When a reference type is assigned or passed as an argument, only the reference to the memory location is copied, not the actual data.</p> <p>These types include:</p> <ul> <li>Array</li> <li>String</li> <li>Struct</li> <li>Mapping</li> </ul>"},{"location":"solidity_tutorial_basics_part_2/#fixed-arrays","title":"Fixed Arrays","text":"<p>Fixed arrays are arrays that store a fixed size collection of elements of the same type.</p> <pre><code>// Declare a fixed array of unsigned integers\nuint[5] fixArray = [10,20,30,40,50];\nfunction retrieveElementArray(uint index) public view returns (uint) {\nreturn fixArray[index];\n}\nfunction retrieveFullArray() public view returns (uint[5] memory) {\nreturn fixArray;\n}\n/*\nretrieveElementArray(0) =&gt; uint256 : 10\nretrieveElementArray(1) =&gt; uint256 : 20\nretrieveElementArray(4) =&gt; uint256 : 50\nSelecting an index outside the stated range will produce an error and revert the EVM to the intial state\nretrieveElementArray(10) =&gt; error\nretrieveFullArray() =&gt; uint256[5] : [10,20,30,40,50]\n*/\n</code></pre> <p><code>uint</code> and <code>uint256</code> are exact aliases and behave exactly the same.</p> <p>In a fixed array, any element not assigned will be set to its default value depending on its type:</p> <pre><code>// Declare a fixed array of unsigned integers\nuint[5] fixArray = [10,30,40,50];\nfunction retrieveElementArray(uint index) public view returns (uint) {\nreturn fixArray[index];\n}\nfunction retrieveFullArray() public view returns (uint[5] memory) {\nreturn fixArray;\n}\n/*\nretrieveElementArray(0) =&gt; uint256 : 10\nretrieveElementArray(1) =&gt; uint256 : 30\nAs this element hasn't beeen assigned, it will be set to 0 (this is the default value for type uint256)\nretrieveElementArray(4) =&gt; uint256 : 0\nretrieveFullArray() =&gt; uint256[5] : [10,30,40,50,0]\n*/\n</code></pre> <p>We can also create temporary arrays stored in memory inside of functions. Unlike arrays in storage, the elements of these arrays would be removed after the execution of the function. </p> <pre><code>function createFixArray() public pure returns (uint[5] memory) {\nuint[5] memory fixArray;\nfixArray[0] = 10;\nfixArray[1] = 20;\nfixArray[2] = 30;\nreturn fixArray;\n}\n</code></pre> <pre><code>// This won't work\nfunction createFixArray() public pure returns (uint[5] memory) {\nuint[5] memory fixArray;\nfixArray = [10,20,30,40,50]; // &lt;= TypeError: Type uint8[5] memory is not implicitly convertible to expected type uint256[5] memory\nreturn fixArray;\n}\n</code></pre> <pre><code>//But this will - array needs to be converted to type uint8\nfunction createFixArray() public pure returns (uint8[5] memory) {\nuint8[5] memory fixArray;\nfixArray = [10,20,30,40,50];\nreturn fixArray;\n}\n</code></pre>"},{"location":"solidity_tutorial_basics_part_2/#dynamic-arrays","title":"Dynamic Arrays","text":"<p>Dynamic arrays unlike fixed sized arrays, can be used to store an arbitrary number of elements of the same type.</p> <pre><code>// Declare a dynamic array of unsigned integers\nuint[] dynArray = [10,20,30,40,50];\nfunction retrieveElementDynArray(uint index) public view returns (uint) {\nreturn dynArray[index];\n}\nfunction retrieveFullDynArray() public view returns (uint[] memory) {\nreturn dynArray;\n}\n// Find the length of the dynamic array\nfunction getLengthArray() public view returns (uint) {\nreturn dynArray.length;\n}\n// Append to array. This will increase the array length by 1.\nfunction appendArray(uint i) public {\ndynArray.push(i);\n}\n// Remove last element from array. This will decrease the array length by 1\nfunction popArray() public {\ndynArray.pop();\n}\n// Delete does not change the array length. It resets the value at index to it's default value which in this case is 0\nfunction removeArray(uint index) public {\ndelete dynArray[index];\n}\n/*\nretrieveElementArray(0) =&gt; uint256 : 10\nretrieveElementArray(1) =&gt; uint256 : 20\nretrieveElementArray(4) =&gt; uint256 : 50\nretrieveFullDynArray() =&gt; uint256[] : [10,20,30,40,50]\ngetLengthArray() =&gt; uint256: 5\nappendArray(80) =&gt; no return value\ndynArray = [10,20,30,40,50,80]\npopArray() =&gt; no return value\ndynArray = [10,20,30,40]\nremoveArray(2) =&gt; no return value\ndynArray = [10,20,0,40,50]\n*/\n</code></pre> <p>Dynamic arrays can only be created in storage. However, we can still create dynamically-allocated fixed arrays. </p> <pre><code>// User calling function can determine size of array using the \"len\" parameter\nfunction createArray(uint len) public pure returns (uint[] memory) {\n// this will still behave like a fixed array so will not inherit dynamic array functions\nuint[] memory arr = new uint[](len);\nreturn arr;\n}\n</code></pre>"},{"location":"solidity_tutorial_basics_part_2/#bytes","title":"Bytes","text":"<p><code>bytes</code> and <code>strings</code> are treated as special arrays that can store an arbitrary length of data. <code>string</code> is equal to <code>bytes</code> but does not allow length or index access. </p> <p>According to the Solidity docs:</p> <p>As a general rule, use <code>bytes</code> for arbitrary-length raw byte data and <code>string</code> for arbitrary-length string (UTF-8) data. If you can limit the length to a certain number of bytes, always use one of the value types <code>bytes1</code> to <code>bytes32</code> because they are much cheaper.</p> <pre><code>bytes message = \"Hello World!\";\nfunction retrieveBytes() public view returns (bytes memory) {\nreturn message;\n}\n// retrieveBytes() =&gt; bytes : 0x48656c6c6f20576f726c6421 ('Hello World!' in ASCII hexadecimal) \n</code></pre> <p>We can store bytes temporarily inside functions too:</p> <pre><code>function storeTempBytes() public pure returns (bytes memory) {\nbytes memory message = \"Hello World!\";\nreturn message;\n}\n// storeTempBytes() =&gt; bytes : 0x48656c6c6f20576f726c6421 ('Hello World!' in ASCII hexadecimal) \n</code></pre>"},{"location":"solidity_tutorial_basics_part_2/#strings","title":"Strings","text":"<p>Strings operate in a similar way as with bytes. However unlike bytes, the output would be in ASCII rather than in hexadecimal.</p> <pre><code>string message = \"Hello World!\";\nfunction retrieveString() public view returns (string memory) {\nreturn message;\n}\n// retrieveString() =&gt; string : Hello World!\n</code></pre> <p>We can store strings temporarily inside functions too:</p> <pre><code>function storeTempString() public pure returns (string memory) {\nstring memory message = \"Hello World!\";\nreturn message;\n}\n// storeTempString() =&gt; string : Hello World!\n</code></pre> <p>Both the <code>bytes</code> and <code>string</code> type have a built-in <code>concat</code> function that can be used to concatenate bytes and strings together:</p> <pre><code>// We can continue to use the 'memory' keyword but 'calldata' uses less gas\n// Function arguments do not need to be of type 'bytes' and can be value type bytes1..32\nfunction concatBytes(bytes calldata b1, bytes calldata b2) public pure returns (bytes memory) {\nbytes memory b3 = bytes.concat(b1, b2);\nreturn b3;\n}\n/*\nEnsure bytes in function arguments are of even length e.g 0xAB or 0xABCD (0xABC would not be permitted)\nconcatBytes(0xab, 0xcd) =&gt; bytes : 0xabcd\n*/\nfunction concatString(string calldata s1, string calldata s2) public pure returns (string memory) {\nstring memory s3 = string.concat(s1, s2);\nreturn s3;\n}\n/*\nconcatString(\"Hello\", \"World!\") =&gt; string : Hello World!\n*/ </code></pre>"},{"location":"solidity_tutorial_basics_part_2/#mappings","title":"Mappings","text":"<p>Mappings in Solidity are hash tables that operate similar to a dictionary in other programming languages (e.g. Python)</p> <pre><code>// Intialise the mapping\nmapping (address =&gt; uint) values;\n// msg.sender is a global variable which is set to the address of the function caller\n// In this example the user can set a value that will be linked to their address  \nfunction setValue(uint amount) public {\nvalues[msg.sender] = amount;\n}\nfunction checkValue() public view returns (uint) {\nreturn values[msg.sender];\n}\n/*\nsetValue(100) =&gt; no return value (but the address has a value of 100 now)\ncheckValue() =&gt; 100 (only if same address was also used for the setValue function above)\n*/ </code></pre>"},{"location":"solidity_tutorial_basics_part_2/#structs","title":"Structs","text":"<p>Structs are used to define new types and group together related data and variables.</p> <pre><code>// In this example we will create the struct \"Car\" and group different variables\nstruct Car {\nstring make;\nstring colour;\nuint price;\nbool isPetrol;\n}\n</code></pre> <p>We can also create an array of type <code>Car</code> to store our structs:</p> <pre><code>struct Car {\nstring make;\nstring colour;\nuint price;\nbool isPetrol;\n}\n// initialise our Car array here\nCar[] cars;\n// lets create a function to create a Car struct and store it in our Car array\nfunction createCar(string calldata _make, string calldata _colour, uint _price, bool _isPetrol) public { Car memory c  = Car(_make, _colour, _price, _isPetrol);\ncars.push(c);\n}\n// we need to return type 'Car' just like other variable types\nfunction retrieveCar(uint index) public view returns (Car memory) {\nreturn cars[index];\n}\n/*\ncreateCar(\"Ford\", \"Red\", 1000, false) =&gt; no return value (but new struct has been created)\n0 would be the index for the first entry\nretrieveCar(0) =&gt; tuple(string,string,uint256,bool): Ford,Red,1000,false\n*/\n</code></pre>"},{"location":"solidity_tutorial_basics_part_3/","title":"Solidity Tutorial - Basics (Part 3)","text":"<p>In the previous tutorial, we looked at the different types of variables and how to assign them. In this section we will look into an essential component in smart contracts (and generally most programming languages) - Functions.</p>"},{"location":"solidity_tutorial_basics_part_3/#functions","title":"Functions","text":"<p>Functions are reusable bits of code that can be called multiple times. In Solidity, they can be declared using the <code>function</code> keyword and the following syntax:</p> <pre><code>function &lt;function-name&gt;(&lt;list of parameters and type&gt;) &lt;visibility&gt; &lt;mutability&gt; &lt;modifier&gt; returns (&lt;type of return value&gt;) {\n&lt;embed logic here&gt;\n}\n</code></pre>"},{"location":"solidity_tutorial_basics_part_3/#function-visibility","title":"Function Visibility","text":"<p>When creating functions, you need to specify who can directly call functions inside of that smart contract by including its function visibility.</p> <p>There are 4 types of visibility:</p> <ul> <li><code>public</code></li> <li><code>private</code></li> <li><code>internal</code></li> <li><code>external</code></li> </ul>"},{"location":"solidity_tutorial_basics_part_3/#public","title":"Public","text":"<p>As the name suggests, public functions with the <code>public</code> keyword will be accessible to all users and contracts. State variables can also be assigned the <code>public</code> keyword, and the compiler will automatically create a getter function.</p> <pre><code>contract Parent {\n// We can make a state variable public and can access it using the getter function created by the compiler\nstring public publicString = \"This is a public function!\";\n// We create a public function that returns a string\nfunction publicFunction() public view returns (string memory) {\nreturn publicString;\n}\n// functions inside of our contract can call this public function\nfunction functionOne() public view returns (string memory) {\nreturn publicFunction();\n}\n}\n// using the \"is\" keyword we can use this to inherit functions\ncontract Child is Parent {\n// functions inherited from another contract can also call this function\nfunction functionTwo() public view returns (string memory) {\nreturn publicFunction();\n}\n}\n</code></pre> <p>We can also call <code>publicFunction()</code> from within another smart contract if contract <code>Parent</code> is deployed on the blockchain:</p> <pre><code>// We first need to declare an interface to interact with another contract\ninterface ParentInterface {\n// functions must be declared as external in the interface even if they are public in the contract they are being called from\nfunction publicFunction() external view returns (string memory);\n}\ncontract AnotherContract {\n// address 0xf8e81D47203A594245E36C48e151709F0C19fBe8 is where our Parent contract is stored (for example sake)\naddress parentAddress = 0xf8e81D47203A594245E36C48e151709F0C19fBe8;\nfunction functionTwo() external view returns (string memory) {\nreturn ParentInterface(parentAddress).publicFunction();\n}\n}\n// functionTwo() =&gt; string : \"This is a public function!\"\n</code></pre>"},{"location":"solidity_tutorial_basics_part_3/#private","title":"Private","text":"<p>Functions and variables labelled as <code>private</code> can only be accessed by the contract that has created the function. They cannot be passed on through inherited contracts or other contracts deployed on the blockchain. </p> <pre><code>contract Parent {\n// This does not have to be declared private for use in a private function\nstring private privateString = \"This is a private function!\";\nfunction privateFunction() private view returns (string memory) {\nreturn privateString;\n}\n// This function will be able to call privateFunction()\nfunction functionOne() public view returns (string memory) {\nreturn privateFunction();\n}\n}\n// Inherited contracts will not be able to inherit private functions\ncontract Child is Parent {\n// This function will not be able to call privateFunction() and produce an error\nfunction functionTwo() public view returns (string memory) {\nreturn privateFunction(); // &lt;= error produced here\n}\n}\n</code></pre>"},{"location":"solidity_tutorial_basics_part_3/#internal","title":"Internal","text":"<p><code>internal</code> functions and variables are similar to <code>private</code> except they can be inherited by other contracts. However they cannot be called from other contracts using an interface:</p> <pre><code>contract Parent {\n// According to Solidity docs, this is the default visibility level for state variables therefore internal keyword is not neccesary\nstring internal internalString = \"This is a internal function!\";\nfunction internalFunction() internal view returns (string memory) {\nreturn internalString;\n}\n// This will work\nfunction functionOne() public view returns (string memory) {\nreturn internalFunction();\n}\n}\n// Inherited contracts will be able to call internal functions\ncontract Child is Parent {\n// This will also work\nfunction functionTwo() public view returns (string memory) {\nreturn internalFunction(); }\n}\n</code></pre>"},{"location":"solidity_tutorial_basics_part_3/#external","title":"External","text":"<p><code>external</code> functions can only be called on the outside by an external user or contract. Variables cannot have the <code>external</code> visibility. </p> <pre><code>contract Parent {\n// Variables cannot be declared external\nstring externalString = \"This is an external function!\";\nfunction externalFunction() external view returns (string memory) {\nreturn externalString;\n}\n// This will not work\nfunction functionOne() public view returns (string memory) {\nreturn externalFunction();\n}\n}\n// Inherited contracts will also NOT be able to call external functions\ncontract Child is Parent {\n// This will NOT work\nfunction functionTwo() public view returns (string memory) {\nreturn externalFunction(); }\n}\n</code></pre>"},{"location":"solidity_tutorial_basics_part_3/#state-mutability","title":"State Mutability","text":"<p>In some of our examples we have repeatedly seen the keywords <code>view</code> and <code>pure</code> used but did not discuss what these terms mean. When defining a function, we can declare whether the function is going to alter the state of the blockchain. If the function simply reads the state, we can declare the function with the <code>view</code> keyword. If the function does not read or write to the state, then we can declare this function as <code>pure</code> . </p> <p>Functions that are declared <code>view</code> or <code>pure</code> will not cost any gas if they are called externally as any computation can be done through the local node. However, if these functions are called internally by other functions, then this will incur a gas fee. </p>"},{"location":"solidity_tutorial_basics_part_3/#return-statement","title":"Return Statement","text":"<p>For a function to return something, you must specify the the <code>returns</code> keyword in the function declaration and include the type that is going to be returned inside brackets. You would then embed the <code>return</code> keyword before the value you would want to return.</p> <p>For instance, if you wanted to create a function to return a number:</p> <pre><code>uint number = 10;\n// we first use the returns key word and specify the type (in this case its uint)\nfunction retrieveNumber() public view returns (uint) {\n// add the return keyword before the value you want to return\nreturn number;\n}\n</code></pre> <p>If you want to return something that is of reference type (e.g. array, string), then you must also specify the data location (most of the times this will be <code>memory</code> ): </p> <pre><code>string myString = \"Hello World!\";\n// The memory keyword must be used here as string is a reference type\nfunction retrieveString() public view returns (string memory) {\nreturn myString;\n}\n</code></pre> <p>If we want to return multiple values, we need to also include their type into the function declaration: </p> <pre><code>uint number = 10;\nstring numAsString = \"Ten\";\nfunction retrieveNumber() public view returns (uint, string memory) {\n// We add brackets which will return a tuple of our values\nreturn (number, numAsString);\n}\n// We can retrieve our values from our function like this\nfunction exampleOne() public view {\n(uint a, string memory b) = retrieveNumber();\n}\n// or like this\nfunction exampleTwo() public view {\nuint a;\nstring memory b;\n(a,b) = retrieve();\n}\n</code></pre>"},{"location":"solidity_tutorial_basics_part_3/#modifiers","title":"Modifiers","text":"<p>Modifiers are special types of functions that can be \u201cadded\u201d to modify the behaviour of an existing function. One common use case for modifiers is to ensure certain conditions are met before the function being called can be invoked e.g. checking to see if user is admin or has required permissions. Whilst modifiers may not be necessary and any logic inside the modifier can be simply embedded into a function, its use makes the code more readable for other developers.  </p> <pre><code>uint256 number;\naddress owner = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;\n// We create a modifier that will only allow the specified address to call a function\nmodifier onlyOwner() {\nrequire(msg.sender == owner, \"Permission Denied - Not the Owner!\");\n// The \"_;\" is a special syntax that determines when you want the modifier to execute\n_;\n}\n// We append the onlyOwner modifier to our function which will be executed first before storeNumber\nfunction storeNumber(uint num) public onlyOwner {\nnumber = num;\n}\n// If we attempt to call the function using a different address than variable \"owner\", it will produce an error and revert the state\n</code></pre> <p>The location of <code>_;</code> is important as it instructs when the code inside the modifier should be run. Anything above the <code>_;</code> is ran before the function (which the modifier has been appended to) is itself executed. Any code that is below <code>_;</code> will be executed after the after the function has finished executing. </p> <p>We can use the previous example to demonstrate this concept:</p> <pre><code>/*\nWe will be calling storeNumber using address 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2\nDepending on where the _; is placed, will determine whether we can call storeNumber\n*/\nuint256 number;\naddress owner = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;\nmodifier onlyOwner() {\n// This line is going to be executed first before storeNumber\n// Since the check comes first, we will not be able to call storeNumber\nrequire(msg.sender == owner, \"Permission Denied - Not the Owner!\");\n_;\n}\nfunction storeNumber(uint num) public onlyOwner {\nnumber = num;\n// Lets change the address of the owner\nowner = 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2\n}\n// In this case we will not be able to call storeNumber as the require statment is executed first before we can change the owner variable\n</code></pre> <pre><code>/*\nBy placing the _; above the require statement we can change the address before running the require function\n*/\nuint256 number;\naddress owner = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;\nmodifier onlyOwner() {\n// we can now change the address of the owner before the require statement\n_;\nrequire(msg.sender == owner, \"Permission Denied - Not the Owner!\");\n}\nfunction storeNumber(uint num) public onlyOwner {\nnumber = num;\nowner = 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2\n}\n// In this example we will now be able call storeNumber using address 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2\n</code></pre> <p>Since the modifier is a function, we can also include function parameters just like normal functions. We will add a modifier to our original code with the condition that <code>number &gt; 10</code>. </p> <pre><code>uint256 number;\naddress owner = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;\nmodifier onlyOwner() {\nrequire(msg.sender == owner, \"Permission Denied - Not the Owner!\");\n// The \"_;\" is a special syntax that determines when you want the modifier to execute\n_;\n}\nmodifier greaterThanTen(uint _number) {\nrequire(_number &gt; 10, \"Number must be greater than 10!\");\n_;\n}\nfunction storeNumber(uint num) public onlyOwner greaterThanTen(num) {\nnumber = num;\n}\n// calling storeNumber(5) will produce an error and revert\n</code></pre>"}]}